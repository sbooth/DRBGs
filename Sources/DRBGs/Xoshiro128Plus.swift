//
// Copyright © 2016-2025 Stephen F. Booth <me@sbooth.org>
// Part of https://github.com/sbooth/DRBGs
// MIT license
//

#if canImport(Darwin)
import Darwin
#elseif canImport(Glibc)
import Glibc
#else
#error("Unsupported Platform")
#endif

/* This is xoshiro128+ 1.0, our best and fastest 32-bit generator for 32-bit
 floating-point numbers. We suggest to use its upper bits for
 floating-point generation, as it is slightly faster than xoshiro128**.
 It passes all tests we are aware of except for
 linearity tests, as the lowest four bits have low linear complexity, so
 if low linear complexity is not considered an issue (as it is usually
 the case) it can be used to generate 32-bit outputs, too.

 We suggest to use a sign test to extract a random Boolean value, and
 right shifts to extract subsets of bits.

 The state must be seeded so that it is not everywhere zero. */

/// An implementation of the xoshiro128+ (XOR/shift/rotate) deterministic random bit generator
///
/// - seealso: https://prng.di.unimi.it
public struct Xoshiro128Plus {
	/// The type of internal state maintained by the generator
	public typealias StateType = (UInt32, UInt32, UInt32, UInt32)

	/// The current state of the generator
	public private(set) var state: StateType = (0, 0, 0, 0)

	/// Initializes the generator with a random seed
	public init() {
		let fd = open("/dev/urandom", O_RDONLY)
		precondition(fd >= 0, "Unable to open /dev/urandom")
		defer {
			close(fd)
		}
		read(fd, &state, MemoryLayout<StateType>.size)
	}

	/// Initializes the generator with a random seed generated by a `RandomNumberGenerator`
	///
	///  - parameter generator: A `RandomNumberGenerator` used to seed the generator
	///
	/// - parameter seed: The initial state
	public init(generator: inout RandomNumberGenerator) {
		state = unsafeBitCast((generator.next(), generator.next()), to: StateType.self)
	}

	/// Initializes the generator with the specified seed
	///
	/// - parameter seed: The initial state
	///
	/// - precondition: `seed` != (0, 0, 0, 0)
	public init(seed: StateType) {
		precondition(seed != (0, 0, 0, 0), "Seed may not be zero")
		state = seed
	}

	/// Generates an unsigned integer in the interval [0, `UInt32.max`]
	///
	/// - returns: An unsigned integer *u* such that 0 ≤ *u* ≤ `UInt32.max`
	public mutating func next() -> UInt32 {
		let result = state.0 &+ state.3
		let t = state.1 << 9

		state.2 ^= state.0
		state.3 ^= state.1
		state.1 ^= state.2
		state.0 ^= state.3

		state.2 ^= t

		state.3.rotateLeft(by: 11)

		return result
	}

	/// The jump function for the generator
	///
	/// It is equivalent to 2^64 calls to `next()`.  It can be used to generate
	/// 2^64 non-overlapping subsequences for parallel computations.
	public mutating func jump() {
		let magic: [UInt32] = [0x8764000b, 0xf542d2d3, 0x6fa035c3, 0x77f2db5b]

		var s0: UInt32 = 0
		var s1: UInt32 = 0
		var s2: UInt32 = 0
		var s3: UInt32 = 0

		for val in magic {
			for bit: UInt32 in 0 ..< 32 {
				if (val & (UInt32(1) << bit)) != 0 {
					s0 ^= state.0
					s1 ^= state.1
					s2 ^= state.2
					s3 ^= state.3
				}
				_ = next()
			}
		}

		state = (s0, s1, s2, s3)
	}

	/// The long-jump function for the generator
	///
	/// It is equivalent to 2^96 calls to `next()`.  It can be used to generate
	/// 2^32 starting points, from each of which `jump()` will generate 2^32
	/// non-overlapping subsequences for parallel distributed computations.
	public mutating func long_jump() {
		let magic: [UInt32] = [0xb523952e, 0x0b6f099f, 0xccf5a0ef, 0x1c580662]

		var s0: UInt32 = 0
		var s1: UInt32 = 0
		var s2: UInt32 = 0
		var s3: UInt32 = 0

		for val in magic {
			for bit: UInt32 in 0 ..< 32 {
				if (val & (UInt32(1) << bit)) != 0 {
					s0 ^= state.0
					s1 ^= state.1
					s2 ^= state.2
					s3 ^= state.3
				}
				_ = next()
			}
		}

		state = (s0, s1, s2, s3)
	}
}

extension Xoshiro128Plus: Equatable {
	/// Compares two `Xoshiro128Plus` objects for equality
	///
	/// Two `Xoshiro128Plus` objects are equal if their 128-bit state is the same.
	///
	/// - parameter lhs: lhs
	/// - parameter rhs: rhs
	///
	/// - returns: `true` if the two objects have the same state, `false` otherwise
	public static func ==(lhs: Xoshiro128Plus, rhs: Xoshiro128Plus) -> Bool {
		lhs.state == rhs.state
	}
}

extension Xoshiro128Plus {
	/// Generates a floating-point number in the interval [0, 1)
	///
	/// - returns: A floating-point number *f* such that 0 ≤ *f* < 1
	@inlinable public mutating func unitFloat() -> Float {
		let x = next()
		return Float(x >> 8) * 0x1.0p-24
	}
}
