//
// SPDX-FileCopyrightText: 2016 Stephen F. Booth <contact@sbooth.dev>
// SPDX-License-Identifier: MIT
//
// Part of https://github.com/sbooth/DRBGs
//

#if canImport(Darwin)
import Darwin
#elseif canImport(Glibc)
import Glibc
#else
#error("Unsupported Platform")
#endif

/* This is xoshiro512+ 1.0, our generator for floating-point numbers with
 increased state size. We suggest to use its upper bits for
 floating-point generation, as it is slightly faster than xoshiro512**.
 It passes all tests we are aware of except for the lowest three bits,
 which might fail linearity tests (and just those), so if low linear
 complexity is not considered an issue (as it is usually the case) it
 can be used to generate 64-bit outputs, too.

 We suggest to use a sign test to extract a random Boolean value, and
 right shifts to extract subsets of bits.

 The state must be seeded so that it is not everywhere zero. If you have
 a 64-bit seed, we suggest to seed a splitmix64 generator and use its
 output to fill s. */

/// An implementation of the xoshiro512+ (XOR/shift/rotate) deterministic random bit generator
///
/// - seealso: https://prng.di.unimi.it
public struct Xoshiro512Plus: RandomNumberGenerator {
	/// The type of internal state maintained by the generator
	public typealias StateType = (UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64)

	/// The current state of the generator
	public private(set) var state: StateType = (0, 0, 0, 0, 0, 0, 0, 0)

	/// Initializes the generator with a random seed
	public init() {
		let fd = open("/dev/urandom", O_RDONLY)
		precondition(fd >= 0, "Unable to open /dev/urandom")
		defer {
			close(fd)
		}
		read(fd, &state, MemoryLayout<StateType>.size)
	}

	/// Initializes the generator with a random seed generated by a `RandomNumberGenerator`
	///
	///  - parameter generator: A `RandomNumberGenerator` used to seed the generator
	///
	/// - parameter seed: The initial state
	public init(generator: inout RandomNumberGenerator) {
		state = (generator.next(), generator.next(), generator.next(), generator.next(), generator.next(), generator.next(), generator.next(), generator.next())
	}

	/// Initializes the generator with the specified seed
	///
	/// - parameter seed: The initial state
	///
	/// - precondition: `seed` != (0, 0, 0, 0, 0, 0, 0, 0)
	public init(seed: StateType) {
		precondition(!(seed.0 == 0 && seed.1 == 0 && seed.2 == 0 && seed.3 == 0 &&
					   seed.4 == 0 && seed.5 == 0 && seed.6 == 0 && seed.7 == 0), "Seed may not be zero")
		state = seed
	}

	/// Generates an unsigned integer in the interval [0, `UInt64.max`]
	///
	/// - returns: An unsigned integer *u* such that 0 â‰¤ *u* â‰¤ `UInt64.max`
	public mutating func next() -> UInt64 {
		let result = state.0 &+ state.2
		let t = state.1 << 11

		state.2 ^= state.0
		state.5 ^= state.1
		state.1 ^= state.2
		state.7 ^= state.3
		state.3 ^= state.4
		state.4 ^= state.5
		state.0 ^= state.6
		state.6 ^= state.7

		state.6 ^= t

		state.7.rotateLeft(by: 21)

		return result
	}

	/// The jump function for the generator
	///
	/// It is equivalent to 2^256 calls to `next()`.  It can be used to generate
	/// 2^256 non-overlapping subsequences for parallel computations.
	public mutating func jump() {
		let magic: [UInt64] = [0x33ed89b6e7a353f9, 0x760083d7955323be, 0x2837f2fbb5f22fae, 0x4b8c5674d309511c, 0xb11ac47a7ba28c25, 0xf1be7667092bcc1c, 0x53851efdb6df0aaf, 0x1ebbc8b23eaf25db]

		var t: StateType = (0, 0, 0, 0, 0, 0, 0, 0)

		for val in magic {
			for bit: UInt64 in 0 ..< 64 {
				if (val & (UInt64(1) << bit)) != 0 {
					t.0 ^= state.0
					t.1 ^= state.1
					t.2 ^= state.2
					t.3 ^= state.3
					t.4 ^= state.4
					t.5 ^= state.5
					t.6 ^= state.6
					t.7 ^= state.7
				}
				_ = next()
			}
		}

		state = t
	}

	/// The long-jump function for the generator
	///
	/// It is equivalent to 2^384 calls to `next()`.  It can be used to generate
	/// 2^128 starting points, from each of which `jump()` will generate 2^128
	/// non-overlapping subsequences for parallel distributed computations.
	public mutating func long_jump() {
		let magic: [UInt64] = [0x11467fef8f921d28, 0xa2a819f2e79c8ea8, 0xa8299fc284b3959a, 0xb4d347340ca63ee1, 0x1cb0940bedbff6ce, 0xd956c5c4fa1f8e17, 0x915e38fd4eda93bc, 0x5b3ccdfa5d7daca5]

		var t: StateType = (0, 0, 0, 0, 0, 0, 0, 0)

		for val in magic {
			for bit: UInt64 in 0 ..< 64 {
				if (val & (UInt64(1) << bit)) != 0 {
					t.0 ^= state.0
					t.1 ^= state.1
					t.2 ^= state.2
					t.3 ^= state.3
					t.4 ^= state.4
					t.5 ^= state.5
					t.6 ^= state.6
					t.7 ^= state.7
				}
				_ = next()
			}
		}

		state = t
	}
}

extension Xoshiro512Plus: Equatable {
	/// Compares two ``Xoshiro512Plus`` objects for equality
	///
	/// Two ``Xoshiro512Plus`` objects are equal if their 512-bit state is the same.
	///
	/// - parameter lhs: lhs
	/// - parameter rhs: rhs
	///
	/// - returns: `true` if the two objects have the same state, `false` otherwise
	public static func ==(lhs: Xoshiro512Plus, rhs: Xoshiro512Plus) -> Bool {
		lhs.state.0 == rhs.state.0 &&
		lhs.state.1 == rhs.state.1 &&
		lhs.state.2 == rhs.state.2 &&
		lhs.state.3 == rhs.state.3 &&
		lhs.state.4 == rhs.state.4 &&
		lhs.state.5 == rhs.state.5 &&
		lhs.state.6 == rhs.state.6 &&
		lhs.state.7 == rhs.state.7
	}
}
