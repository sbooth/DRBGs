//
// Copyright © 2016-2024 Stephen F. Booth <me@sbooth.org>
// Part of https://github.com/sbooth/DRBGs
// MIT license
//

#if canImport(Darwin)
import Darwin
#elseif canImport(Glibc)
import Glibc
#else
#error("Unsupported Platform")
#endif

/* This is xoshiro512++ 1.0, one of our all-purpose, rock-solid
 generators. It has excellent (about 1ns) speed, a state (512 bits) that
 is large enough for any parallel application, and it passes all tests
 we are aware of.

 For generating just floating-point numbers, xoshiro512+ is even faster.

 The state must be seeded so that it is not everywhere zero. If you have
 a 64-bit seed, we suggest to seed a splitmix64 generator and use its
 output to fill s. */

/// An implementation of the xoshiro512++ (XOR/shift/rotate) deterministic random bit generator
///
/// - seealso: https://prng.di.unimi.it
public struct Xoshiro512PlusPlus: RandomNumberGenerator {
	/// The type of internal state maintained by the generator
	public typealias StateType = (UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64)

	/// The current state of the generator
	public private(set) var state: StateType = (0, 0, 0, 0, 0, 0, 0, 0)

	/// Initializes the generator with a random seed
	public init() {
		let fd = open("/dev/urandom", O_RDONLY)
		precondition(fd >= 0, "Unable to open /dev/urandom")
		defer {
			close(fd)
		}
		read(fd, &state, MemoryLayout<StateType>.size)
	}

	/// Initializes the generator with a random seed generated by a `RandomNumberGenerator`
	///
	///  - parameter generator: A `RandomNumberGenerator` used to seed the generator
	///
	/// - parameter seed: The initial state
	public init(generator: inout RandomNumberGenerator) {
		state = (generator.next(), generator.next(), generator.next(), generator.next(), generator.next(), generator.next(), generator.next(), generator.next())
	}

	/// Initializes the generator with the specified seed
	///
	/// - parameter seed: The initial state
	///
	/// - precondition: `seed` != (0, 0, 0, 0, 0, 0, 0, 0)
	public init(seed: StateType) {
		precondition(!(seed.0 == 0 && seed.1 == 0 && seed.2 == 0 && seed.3 == 0 &&
					   seed.4 == 0 && seed.5 == 0 && seed.6 == 0 && seed.7 == 0), "Seed may not be zero")
		state = seed
	}

	/// Generates an unsigned integer in the interval [0, `UInt64.max`]
	///
	/// - returns: An unsigned integer *u* such that 0 ≤ *u* ≤ `UInt64.max`
	public mutating func next() -> UInt64 {
		let result = (state.0 &+ state.2).rotatedLeft(by: 17) &+ state.2
		let t = state.1 << 11

		state.2 ^= state.0
		state.5 ^= state.1
		state.1 ^= state.2
		state.7 ^= state.3
		state.3 ^= state.4
		state.4 ^= state.5
		state.0 ^= state.6
		state.6 ^= state.7

		state.6 ^= t

		state.7.rotateLeft(by: 21)

		return result
	}

	/// The jump function for the generator
	///
	/// It is equivalent to 2^256 calls to `next()`.  It can be used to generate
	/// 2^256 non-overlapping subsequences for parallel computations.
	public mutating func jump() {
		let magic: [UInt64] = [0x33ed89b6e7a353f9, 0x760083d7955323be, 0x2837f2fbb5f22fae, 0x4b8c5674d309511c, 0xb11ac47a7ba28c25, 0xf1be7667092bcc1c, 0x53851efdb6df0aaf, 0x1ebbc8b23eaf25db]

		var t: StateType = (0, 0, 0, 0, 0, 0, 0, 0)

		for val in magic {
			for bit: UInt64 in 0 ..< 64 {
				if (val & (UInt64(1) << bit)) != 0 {
					t.0 ^= state.0
					t.1 ^= state.1
					t.2 ^= state.2
					t.3 ^= state.3
					t.4 ^= state.4
					t.5 ^= state.5
					t.6 ^= state.6
					t.7 ^= state.7
				}
				_ = next()
			}
		}

		state = t
	}

	/// The long-jump function for the generator
	///
	/// It is equivalent to 2^384 calls to `next()`.  It can be used to generate
	/// 2^128 starting points, from each of which `jump()` will generate 2^128
	/// non-overlapping subsequences for parallel distributed computations.
	public mutating func long_jump() {
		let magic: [UInt64] = [0x11467fef8f921d28, 0xa2a819f2e79c8ea8, 0xa8299fc284b3959a, 0xb4d347340ca63ee1, 0x1cb0940bedbff6ce, 0xd956c5c4fa1f8e17, 0x915e38fd4eda93bc, 0x5b3ccdfa5d7daca5]

		var t: StateType = (0, 0, 0, 0, 0, 0, 0, 0)

		for val in magic {
			for bit: UInt64 in 0 ..< 64 {
				if (val & (UInt64(1) << bit)) != 0 {
					t.0 ^= state.0
					t.1 ^= state.1
					t.2 ^= state.2
					t.3 ^= state.3
					t.4 ^= state.4
					t.5 ^= state.5
					t.6 ^= state.6
					t.7 ^= state.7
				}
				_ = next()
			}
		}

		state = t
	}
}

extension Xoshiro512PlusPlus: Equatable {
	/// Compares two ``Xoshiro512PlusPlus`` objects for equality
	///
	/// Two ``Xoshiro512PlusPlus`` objects are equal if their 512-bit state is the same.
	///
	/// - parameter lhs: lhs
	/// - parameter rhs: rhs
	///
	/// - returns: `true` if the two objects have the same state, `false` otherwise
	public static func ==(lhs: Xoshiro512PlusPlus, rhs: Xoshiro512PlusPlus) -> Bool {
		lhs.state.0 == rhs.state.0 &&
		lhs.state.1 == rhs.state.1 &&
		lhs.state.2 == rhs.state.2 &&
		lhs.state.3 == rhs.state.3 &&
		lhs.state.4 == rhs.state.4 &&
		lhs.state.5 == rhs.state.5 &&
		lhs.state.6 == rhs.state.6 &&
		lhs.state.7 == rhs.state.7
	}
}
