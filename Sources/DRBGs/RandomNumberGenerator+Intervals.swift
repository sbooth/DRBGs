//
// Copyright © 2016-2024 Stephen F. Booth <me@sbooth.org>
// Part of https://github.com/sbooth/DRBGs
// MIT license
//

// ============================================================
// Begin Boost-inspired code

// The functions in the extension below were inspired by boost/random
// from the Boost C++ library (http://www.boost.org)

/*
 * Copyright Jens Maurer 2000-2001
 * Copyright Steven Watanabe 2011
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

extension RandomNumberGenerator {
	/// Generates an unsigned integer in the interval [`min`, `max`]
	///
	/// - parameter min: The interval's lower endpoint
	/// - parameter max: The interval's upper endpoint
	///
	/// - returns: An unsigned integer *u* such that `min` ≤ *u* ≤ `max`
	///
	/// - precondition: `min` <= `max`
	public mutating func next(min: UInt64 = 0, max: UInt64) -> UInt64 {
		precondition(min <= max)

		let range = max - min
		if range == 0 {
			return 0
		} else if range == UInt64.max {
			return next() /*+ min*/
		} else {
			var bucketSize = UInt64.max / (range + 1)
			if UInt64.max % (range + 1) == range {
				bucketSize += 1
			}

			while true {
				var result = next()
				result /= bucketSize
				if result <= range {
					return result + min
				}
			}
		}
	}

	/// Generates a signed integer in the interval [0, `max`]
	///
	/// - parameter max: The interval's upper endpoint
	///
	/// - returns: A signed integer *i* such that 0 ≤ *i* ≤ `max`
	///
	/// - precondition: `max` >= 0
	public mutating func next(max: Int) -> Int {
		precondition(max >= 0)

		let range = UInt64(max)

		if range == 0 {
			return 0
		}
//		else if range == UInt64.max {
//			return Int(next())
//		}
		else {
			var bucketSize = UInt64.max / (range + 1)
			if UInt64.max % (range + 1) == range {
				bucketSize += 1
			}

			while true {
				var result = next()
				result /= bucketSize
				if result <= range {
					return Int(result)
				}
			}
		}
	}

	/// Generates a signed integer in the interval [`min`, `max`]
	///
	/// - parameter min: The interval's lower endpoint
	/// - parameter max: The interval's upper endpoint
	///
	/// - returns: A signed integer *i* such that `min` ≤ *i* ≤ `max`
	///
	/// - precondition: `min` <= `max`
	public mutating func next(min: Int, max: Int) -> Int {
		precondition(min <= max)

		let range = _subtract(x: max, y: min)

		if range == 0 {
			return 0
		} else if range == UInt64.max {
			return _add(x: next(), y: min)
		} else {
			var bucketSize = UInt64.max / (range + 1)
			if UInt64.max % (range + 1) == range {
				bucketSize += 1
			}

			while true {
				var result = next()
				result /= bucketSize
				if result <= range {
					return _add(x: result, y: min)
				}
			}
		}
	}

	/// Generates a floating-point number in the interval [`min`, `max`)
	///
	/// - parameter min: The interval's lower endpoint
	/// - parameter max: The interval's upper endpoint
	///
	/// - returns: A floating-point number *f* such that `min` ≤ *f* < `max`
	///
	/// - precondition: `min` < `max`
	public mutating func next<T: FloatingPoint>(min: T = 0, max: T = 1) -> T {
		precondition(min < max)

		let halfMin = min / 2
		let halfMax = max / 2
		if halfMax - halfMin > T.greatestFiniteMagnitude / 2 {
			return T(2) * next(min: halfMin, max: halfMax)
		}

		while true {
			let result = T(next()) / T(UInt64.max) * (max - min) + min
			if result < max {
				return result
			}
		}
	}
}

/// Subtracts `x` from `y`
///
/// This function handles cases that would normally overflow, such as
/// `Int.max` - `Int.min`
///
/// - parameter x: A signed integer
/// - parameter y: A signed integer
///
/// - returns: The difference between `x` and `y` as an unsigned integer
///
/// - precondition: x >= y
private func _subtract(x: Int, y: Int) -> UInt64 {
	if y >= 0 {
		return UInt64(x) - UInt64(y)
	} else if x >= 0 {
		return UInt64(x) + UInt64(-(y + 1)) + 1
	} else {
		return UInt64(x - y)
	}
}

/// Adds `x` to `y`
///
/// This function handles the case `y` == `Int.min` correctly
///
/// - parameter x: An unsigned integer
/// - parameter y: A signed integer
///
/// - returns: The sum of `x` and `y` as a signed integer
private func _add(x: UInt64, y:Int) -> Int {
	if y >= 0 {
		return Int(x) + y
	} else if x > UInt64(-(y + 1)) {
		return Int(x - UInt64(-(y + 1)) - 1)
	} else {
		return Int(x) + y
	}
}

// End Boost-inspired code
// ============================================================

// The code for unitDouble() was taken from https://prng.di.unimi.it
extension RandomNumberGenerator {
	/// Generates a floating-point number in the interval [0, 1)
	///
	/// - returns: A floating-point number *f* such that 0 ≤ *f* < 1
	public mutating func unitDouble() -> Double {
		let x = next()
		return Double((x >> 11)) * 0x1.0p-53
	}
}
